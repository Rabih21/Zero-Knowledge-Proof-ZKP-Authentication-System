<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Login</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="container">
    <div class="card">
      <h2>Sign In</h2>
      <div class="input-group">
        <label>Username</label>
        <input type="text" id="u" placeholder="Enter username">
      </div>
      <div class="input-group">
        <label>Password</label>
        <input type="password" id="p" placeholder="Enter password">
      </div>
      <button class="btn" onclick="login()">Login</button>
      <a href="/register" style="display:block; margin-top:1.5rem;">Don't have an account?</a>
      <pre id="log" class="result" style="display:none;"></pre>
    </div>
  </div>
  <script>
    async function login() {
      const u = document.getElementById('u').value;
      const p = document.getElementById('p').value;
      const log = document.getElementById('log');
      
      // Step 1: Get salt and challenge
      const start = await fetch('/login/start', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username: u})
      });
      const sData = await start.json();
      if (!start.ok) {
        log.style.display = 'block';
        log.textContent = JSON.stringify(sData, null, 2);
        return;
      }

      // Step 2: Compute ZKP values in-browser (no crypto.js needed!)
      const salt = sData.salt;
      const challenge = BigInt(sData.challenge);

      // Hash function (matches Python's H)
      async function H(...args) {
        const msg = args.map(String).join('');
        const buf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(msg));
        return BigInt("0x" + Array.from(new Uint8Array(buf), b => b.toString(16).padStart(2,'0')).join(''));
      }

      const P = BigInt("0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF");
      const G = 2n;

      // Secure randomness
      function rand() {
        const arr = new Uint32Array(4);
        crypto.getRandomValues(arr);
        let r = 0n;
        for (let i = 0; i < arr.length; i++) r = (r << 32n) + BigInt(arr[i]);
        return r % (P - 1n);
      }

      // Modular exponentiation
      function modPow(base, exp, mod) {
        let result = 1n;
        base %= mod;
        while (exp > 0n) {
          if (exp & 1n) result = (result * base) % mod;
          exp >>= 1n;
          base = (base * base) % mod;
        }
        return result;
      }

      // Compute x = H(salt, password)
      const x = await H(salt, p);
      const r = rand();
      const A = modPow(G, r, P);
      const e = await H(A, challenge);
      const s = (r + e * x) % (P - 1n);

      // Step 3: Send proof
      const finish = await fetch('/login/finish', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({A: A.toString(), s: s.toString()})
      });
      const result = await finish.json();
      log.style.display = 'block';
      log.textContent = JSON.stringify(result, null, 2);
      
      if (result.redirect) window.location = result.redirect;
    }
  </script>
</body>
</html>